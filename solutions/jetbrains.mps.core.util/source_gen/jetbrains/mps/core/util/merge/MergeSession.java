package jetbrains.mps.core.util.merge;

/*Generated by MPS */

import jetbrains.mps.messages.IMessageHandler;
import java.util.Map;
import org.jetbrains.mps.openapi.model.SNode;
import org.jetbrains.mps.openapi.model.EditableSModel;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.internal.collections.runtime.MapSequence;
import java.util.HashMap;
import jetbrains.mps.extapi.model.SModelBase;
import jetbrains.mps.messages.Message;
import jetbrains.mps.messages.MessageKind;
import jetbrains.mps.smodel.SModelStereotype;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.internal.collections.runtime.IMapping;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.util.SNodeOperations;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.smodel.ModelAccess;
import jetbrains.mps.extapi.model.EditableSModelBase;
import java.util.List;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.internal.collections.runtime.backports.LinkedList;
import java.util.ArrayList;
import java.util.Collections;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;

public class MergeSession {
  private IMessageHandler messageHandler;
  private Map<SNode, SNode> mapping;
  private Map<SNode, SNode> reverseMapping;
  private Map<EditableSModel, SModel> newContent;

  public MergeSession(IMessageHandler messageHandler) {
    this.messageHandler = messageHandler;
    this.mapping = MapSequence.fromMap(new HashMap<SNode, SNode>());
    this.reverseMapping = MapSequence.fromMap(new HashMap<SNode, SNode>());
    this.newContent = MapSequence.fromMap(new HashMap<EditableSModel, SModel>());
  }

  public boolean isMapped(SNode node) {
    return MapSequence.fromMap(mapping).containsKey(node);
  }

  public void replace(EditableSModel model, Iterable<SNode> roots) {
    jetbrains.mps.smodel.SModel existing = ((SModelBase) model).getSModelInternal();
    if (existing == null) {
      messageHandler.handle(new Message(MessageKind.ERROR, "no " + SModelStereotype.withoutStereotype(model.getModelName()) + " model"));
      return;
    }

    final jetbrains.mps.smodel.SModel newmodel = existing.createEmptyCopy();
    existing.copyPropertiesTo(newmodel.getModelDescriptor());
    Sequence.fromIterable(mergeLists((Iterable<SNode>) model.getRootNodes(), roots, newmodel.getModelDescriptor())).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        newmodel.addRootNode(it);
      }
    });
    MapSequence.fromMap(newContent).put(model, newmodel.getModelDescriptor());
  }

  public void restoreRefs() {
    for (IMapping<SNode, SNode> m : MapSequence.fromMap(mapping)) {
      SNode input = m.key();
      SNode output = m.value();

      for (SReference ref : SNodeOperations.getReferences(input)) {
        SNode targetNode = SNodeOperations.getTargetNodeSilently(ref);
        if (targetNode == null) {
          messageHandler.handle(new Message(MessageKind.ERROR, "broken reference `" + ref.getRole() + "' in " + SNodeOperations.getDebugText(input)));
          continue;
        }
        if (MapSequence.fromMap(mapping).containsKey(targetNode)) {
          SNodeAccessUtil.setReferenceTarget(output, ref.getRole(), MapSequence.fromMap(mapping).get(targetNode));
        } else {
          SNodeAccessUtil.setReferenceTarget(output, ref.getRole(), targetNode);
        }
      }
    }

    this.mapping = null;
    this.reverseMapping = null;
  }

  public void apply() {
    ModelAccess.assertLegalWrite();

    for (IMapping<EditableSModel, SModel> entry : MapSequence.fromMap(newContent)) {
      final EditableSModel descriptor = entry.key();
      messageHandler.handle(new Message(MessageKind.INFORMATION, "replacing " + descriptor.getModelName()));
      descriptor.updateTimestamp();
      ((EditableSModelBase) descriptor).replace(((SModelBase) entry.value()).getSModelInternal());
      descriptor.setChanged(true);
      ModelAccess.instance().runWriteInEDT(new Runnable() {
        public void run() {
          descriptor.save();
        }
      });
    }
  }

  private Iterable<SNode> mergeLists(Iterable<SNode> existing, Iterable<SNode> created, final SModel newmodel) {
    final Map<String, List<SNode>> existingNodes = MapSequence.fromMap(new HashMap<String, List<SNode>>());
    Sequence.fromIterable(existing).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String signature = getSignature(it);
        if (!(MapSequence.fromMap(existingNodes).containsKey(signature))) {
          MapSequence.fromMap(existingNodes).put(signature, ListSequence.fromList(new LinkedList<SNode>()));
        }
        ListSequence.fromList(MapSequence.fromMap(existingNodes).get(signature)).addElement(it);
      }
    });
    final List<SNode> result = new ArrayList<SNode>();
    Sequence.fromIterable(created).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        String signature = getSignature(it);
        SNode existingNode = (MapSequence.fromMap(existingNodes).containsKey(signature) ?
          ListSequence.fromList(MapSequence.fromMap(existingNodes).get(signature)).removeElementAt(0) :
          null
        );
        ListSequence.fromList(result).addElement(merge(existingNode, it, newmodel));
      }
    });
    return result;
  }

  protected SNode merge(SNode existing, SNode node, SModel newmodel) {
    if (node == null) {
      return null;
    }
    SNode result = new jetbrains.mps.smodel.SNode(node.getConcept().getQualifiedName());
    MapSequence.fromMap(mapping).put(node, result);
    MapSequence.fromMap(reverseMapping).put(result, node);
    ((jetbrains.mps.smodel.SNode) result).putProperties((jetbrains.mps.smodel.SNode) node);
    ((jetbrains.mps.smodel.SNode) result).putUserObjects((jetbrains.mps.smodel.SNode) node);
    if (existing != null) {
      ((jetbrains.mps.smodel.SNode) result).setId(existing.getNodeId());
    }
    for (SNode child : mergeLists((existing == null ?
      Sequence.fromIterable(Collections.<SNode>emptyList()) :
      jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getChildren(existing)
    ), jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getChildren(node), newmodel)) {
      String role = MapSequence.fromMap(reverseMapping).get(child).getRoleInParent();
      assert role != null;
      result.addChild(role, child);
    }
    return result;
  }

  protected String getSignature(SNode node) {
    String signature = ((jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getParent(node) == null) ?
      "{root}" :
      jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.getContainingLinkRole(node)
    );
    assert signature != null;
    if (jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.isInstanceOf(node, "jetbrains.mps.lang.core.structure.INamedConcept")) {
      signature = "#" + SPropertyOperations.getString(jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations.cast(node, "jetbrains.mps.lang.core.structure.INamedConcept"), "name");
    }
    return signature;
  }
}
